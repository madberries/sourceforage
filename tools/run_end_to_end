#!/usr/bin/env python3
#
# USAGE: run_end_to_end <cve> <path-to-webapp>
#
# EXIT_CODE: 0 if exploit was excersid, otherwise 1.

import glob
import itertools
import os
import re
import requests
import shutil
import subprocess
import sys
import time

from bs4 import BeautifulSoup
from subprocess import DEVNULL, PIPE, STDOUT
from tempfile import mkstemp
from threading import Thread

from http.server import HTTPServer, BaseHTTPRequestHandler

# "Constants"
haccs_cmd_dir = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
possible_config_names = [ 'common.php', 'config.php' ]
dbhost = 'localhost'
dbname = 'somedb'
dbuser = 'root'
dbpass = ''
dbhost_rep = [['dbhost', 'hostname'], [dbhost]]
dbname_rep = [['dbname', 'default_db'], [dbname]]
dbuser_rep = [['dbuser', 'dbusername'], [dbuser]]
dbpass_rep = [['dbpass', 'dbpassword'], [dbpass]]
addr = '172.17.0.1'
port = 5000
exploit_timeout = 30

def sed0(fin, fout, pattern, replace, count):
    num_replaced = count
    success = False

    for line in fin:
        out = re.sub(pattern, replace, line)
        fout.write(out)

        if out != line:
            success = True
            num_replaced += 1
        if count and num_replaced > count:
            break

    try:
        fout.writelines(fin.readlines())
    except Exception as E:
        raise E

    return success

def sed(pattern, replace, source, dest=None, count=0):
    """Reads a source file and writes the destination file.

    In each line, replaces pattern with replace.

    Args:
        pattern (str): pattern to match (can be re.pattern)
        replace (str): replacement str
        source  (str): input filename
        count (int): number of occurrences to replace
        dest (str): destination filename, if not given, source will
                    be over written.
    """

    success = False
    with open(source, 'r') as fin:
        if dest:
            with open(dest, 'w') as fout:
                success = sed0(fin, fout, pattern, replace, count)
        else:
            fd, name = mkstemp()
            with open(name, 'w') as fout:
                success = sed0(fin, fout, pattern, replace, count)

    if not dest:
        shutil.move(name, source)

    return success

def make_replacements(replacement_list):
    for varname, value in itertools.product(*replacement_list):
        if sed(r'(^\$' + varname + '\s*=\s*("|\'))[^"]+(("|\')\s*;.*$)',
                r'\1' + value + r'\3', config_file, count=1):
            break

def strip_ansi_color(data):
    """Remove ANSI colors from string or bytes."""
    if isinstance(data, bytes):
        data = data.decode("utf-8")

    # Taken from tabulate
    invisible_codes = re.compile(r"\x1b\[\d*m")

    return re.sub(invisible_codes, "", data)

def stop_docker(container_id, image_name):
    print('Stopping docker container (%s) for image \'%s\'... ' %
            (container_id, image_name), end='')
    subprocess.run(['docker', 'stop', container_id], stdout=DEVNULL)
    print('DONE!')

def get_running_dockers(name=None):
    running_dockers = []
    if name is None:
        out, _ = subprocess.Popen(['docker', 'container', 'ls'],
                stdout=PIPE).communicate()
    else:
        out, _ = subprocess.Popen(['docker', 'container', 'ls',
            '-f', 'ancestor=' + name], stdout=PIPE).communicate()
    out = out.splitlines()[1:]  # grab only the relevant lines
    for line in out:
        split_line = line.decode('utf-8').split()
        running_dockers.append(split_line[0])
    return running_dockers

class HTTPHandler(BaseHTTPRequestHandler):
    def do_HEAD(self):
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.end_headers()

    def do_GET(self):
        self.send_response(200)
        self.send_header("Content-type", "text/x-shellscript")
        self.end_headers()
        self.wfile.write(bytes('#!/bin/sh\n\ntouch /tmp/TESTFILE\n\n', 'utf-8'))
        globals()['received'] = True

class ExploitChecker(Thread):

    def __init__(self):
        Thread.__init__(self)
        self.server = HTTPServer((addr, port), HTTPHandler)
        self.start()

    def run(self):
        print('Started http server on %s:%d' % (addr, port))
        self.server.handle_request()   # just handle one request

if __name__ == "__main__":
    globals()['received'] = False
    if len(sys.argv) != 3:
        print('USAGE: %s <cve> <path-to-webapp>' % sys.argv[0], file=sys.stderr)
        exit(1)

    # Extract CVE directory from application path.
    cve = sys.argv[1]
    path_to_app = sys.argv[2]
    cve_dir = os.path.dirname(os.path.dirname(path_to_app))
    if cve_dir == '':
        print('ERROR: Unable to locate CVE directory relative to: '
                + path_to_app, file=sys.stderr)

    # Step 1) Find a configuration file, and check for hardcoded database
    #         information (i.e. host, user, pass, etc...) replacing the
    #         values needed for our particular setup.
    for config_name in possible_config_names:
        to_search = path_to_app + '/**/' + config_name
        for config_file in glob.glob(to_search, recursive=True):
            make_replacements(dbhost_rep)
            make_replacements(dbname_rep)
            make_replacements(dbuser_rep)
            make_replacements(dbpass_rep)

    # Step 2) Run the docker container.
    p = subprocess.Popen([ './run.sh' ], stdout=PIPE, stderr=STDOUT, cwd=cve_dir)
    initialized = False
    while True:
        output = p.stdout.readline()
        if output == '' and p.poll() is not None:
            break
        if output:
            line = output.strip().decode("utf-8")
            print(line)
            if line == 'App DB setup complete.':
                initialized = True
                break
        else:
            print('ERROR: unexpected EOF!', file=sys.stderr)
            break

    found_exploit = False
    if initialized:
        # Wait a couple seconds after initialization for good measure!
        time.sleep(2.0)

        #######################################################################
        # Step 3) Locate and run the install script (if there is one)         #
        #######################################################################
        to_search = path_to_app + '/**/install.php'
        for install_file in glob.glob(to_search, recursive=True):
            path_to_install = os.path.relpath(install_file, path_to_app)
            url = 'http://localhost/' + path_to_install
            print('Attempting to install software from URL: ' + url)
            page = requests.get(url)
            if page.status_code != 200:
                print('ERROR: %s returned status code = %d'
                        % (url, page.status_code))
                continue
            contents = page.content
            print(contents)

            # TODO: Handle case where the install script returns a form.
            #soup = BeautifulSoup(contents, 'html.parser')
            break  # Only process the first script found

        # Wait for the exploit to trigger by reading from the fifo that the
        # flask server will be writing to.
        checker = ExploitChecker()
        cve_base = os.path.basename(cve_dir)
        exploits_dir = os.path.join(haccs_cmd_dir, 'comfortfuzz/exploits')
        json_out_dir = os.path.join(haccs_cmd_dir, 'comfortfuzz/json_out')
        cmd = ['docker', 'run', '--volume', exploits_dir + ':/exploits',
                '--volume', json_out_dir + ':/json_out', '--rm', '-it',
                'comfortfuzz', './run_exploit', cve_base]
        subprocess.run(cmd) # wait for proc!

        checker.join(timeout=exploit_timeout)
        found_exploit = globals()['received']
        if checker.is_alive():
            # Eat the request in case we timed out, so this thread can die!
            print('ERROR: Timed-out in the ExploitChecker! Eating the HTTP '
                  'request...', file=sys.stderr)
            requests.get('http://%s:%s' % (addr, port))
            checker.join()
    else:
        print('ERROR: Docker did not initialize!', file=sys.stderr)

    # TODO: Since this is process cleanup, we should put this in a trap.
    # Stop the docker container, and wait for it to die
    image_name = 'aarno-' + cve.lower()
    for docker in get_running_dockers(name=image_name):
        stop_docker(docker, image_name)

    # Did we exercise the exploit?
    if found_exploit:
        print('SUCCESS: exploit was exercised!')
        exit(0)
    else:
        print('FAILURE: exploit was not exercised!')
        exit(1)
