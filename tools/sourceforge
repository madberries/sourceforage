#!/usr/bin/env python3
#
# usage: sourceforge [-h] [-v] infiles [infiles ...]
#
# Discovers and generates PHPexploits automatically (via sourceforge) from NVD
# json data feed
#
# positional arguments:
#   infiles         Compressed json file as downloaded from NVD's website, e.g.
#                   https://nvd.nist.gov/feeds/json/cve/1.0/nvdcve-1.0-2018.json
#                   .gz
#
# optional arguments:
#   -h, --help      show this help message and exit
#   -v, --verified  Run only CVEs that have been verified to work end-to-end

import os
import sys

# Make sure that the HACCSTA2_HOME env var is set, since we need to add this to
# our python path
haccs_ta2_home = os.environ.get('HACCSTA2_HOME')
if haccs_ta2_home is None:
    print('ERROR: HACCSTA2_HOME is not set (this should point to the root of '
            'the \'haccs-ta2\' repo)', file=sys.stderr)
    exit(1)
sys.path.append(os.path.join(haccs_ta2_home, 'cve2'))
from cve import CVE, Product

import argparse
import gzip
import json
import shutil

from impl.scrapers import SourceforgeScraper
from impl.helpers.constants import CAPABLE_OF_WORKING, SOURCEFORGE_DIR

def main(cmd_line):
    # Parse through all NVD files specified on the command line:
    nvd_inputs = []
    for infile in cmd_line.infiles:
        if ("gz" in infile):
            with gzip.GzipFile(infile, 'r') as f:
                input = (json.load(f))
                input['filename'] = infile
                nvd_inputs.append (input)
        else:
            with open (infile, 'r') as f:
                input = (json.load(f))
                input['filename'] = infile
                nvd_inputs.append (input)

    # Start from a fresh sourceforge directory
    if os.path.exists(SOURCEFORGE_DIR):
        if not os.path.isdir(SOURCEFORGE_DIR):
            print('ERROR: \'%s\' already exists, and is not a directory'
                    % SOURCEFORGE_DIR, file=sys.stderr)
            exit(1)
        shutil.rmtree(SOURCEFORGE_DIR)
    os.mkdir(SOURCEFORGE_DIR)

    # For each json file, parse the CVE items and determine whther this is a
    # queriable SQL injection.
    for nvd_data in nvd_inputs:
        print("Have %d CVEs to process from %s" %
                (len(nvd_data['CVE_Items']),nvd_data['filename']))

        for cve_base in nvd_data['CVE_Items']:
            cve = CVE(cve_base)

            # If we are only running CVEs that have been verified to work
            # end-to-end, and this CVE is not one that has been verified
            # to work, then skip this CVE.
            if cmd_line.verified and not cve.cve.lower() in \
                    CAPABLE_OF_WORKING.keys():
                continue

            # Make sure CPE information was found, so we can pull the version
            # number easily from this
            if len(cve.cpe_list_flat) <= 0:
                continue

            sourceforge_scraper = \
                    SourceforgeScraper(cve,
                                       check_only_verified=cmd_line.verified)
            sourceforge_scraper.scrape_and_run()

def parse_args():
    """
    parse command line arguments
    """
    parser = argparse.ArgumentParser(description='Discovers and generates PHP'
            'exploits automatically (via sourceforge) from NVD json data feed')
    parser.add_argument('infiles', nargs="+",
            help="Compressed json file as downloaded from NVD's website, e.g. "
            "https://nvd.nist.gov/feeds/json/cve/1.0/nvdcve-1.0-2018.json.gz")
    parser.add_argument('-v', '--verified', action='store_true',
            help='Run only CVEs that have been verified to work end-to-end')
    return parser.parse_args()

if __name__ == "__main__":
    args = parse_args()
    sys.exit(main(args))
