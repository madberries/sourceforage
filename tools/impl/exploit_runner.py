import glob
import os
import requests
import subprocess
import sys
import time

from bs4 import BeautifulSoup
from helpers.process_utils import run_cmd, get_running_dockers, stop_docker
from helpers.string_utils import make_replacements
from http.server import HTTPServer, BaseHTTPRequestHandler
from subprocess import PIPE, STDOUT

from .exploit_checker import ExploitChecker, http_server_addr, http_server_port

# "Constants"
haccs_cmd_dir = os.path.dirname(
        os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
)
possible_config_names = [ 'common.php', 'config.php' ]
dbhost = 'localhost'
dbname = 'somedb'
dbuser = 'root'
dbpass = ''
dbhost_rep = [['dbhost', 'hostname'], [dbhost]]
dbname_rep = [['dbname', 'default_db'], [dbname]]
dbuser_rep = [['dbuser', 'dbusername'], [dbuser]]
dbpass_rep = [['dbpass', 'dbpassword'], [dbpass]]
exploit_timeout = 30

def run_exploit(cve, path_to_app):
    # Extract CVE directory from application path.
    cve_dir = os.path.dirname(os.path.dirname(path_to_app))
    if cve_dir == '':
        print('ERROR: Unable to locate CVE directory relative to: '
                + path_to_app, file=sys.stderr)

    # Step 1) Find a configuration file, and check for hardcoded database
    #         information (i.e. host, user, pass, etc...) replacing the
    #         values needed for our particular setup.
    for config_name in possible_config_names:
        to_search = path_to_app + '/**/' + config_name
        for config_file in glob.glob(to_search, recursive=True):
            make_replacements(dbhost_rep, config_file)
            make_replacements(dbname_rep, config_file)
            make_replacements(dbuser_rep, config_file)
            make_replacements(dbpass_rep, config_file)

    # Step 2) Run the docker container.
    p = subprocess.Popen([ './run.sh' ], stdout=PIPE, stderr=STDOUT,
                         cwd=cve_dir)
    initialized = False
    while True:
        output = p.stdout.readline()
        if output == '' and p.poll() is not None:
            break
        if output:
            line = output.strip().decode("utf-8")
            print(line)
            if line == 'App DB setup complete.':
                initialized = True
                break
        else:
            print('ERROR: unexpected EOF!', file=sys.stderr)
            break

    found_exploit = False
    if initialized:
        # Wait a couple seconds after initialization for good measure!
        time.sleep(2.0)

        #######################################################################
        # Step 3) Locate and run the install script (if there is one)         #
        #######################################################################
        to_search = path_to_app + '/**/install.php'
        for install_file in glob.glob(to_search, recursive=True):
            path_to_install = os.path.relpath(install_file, path_to_app)
            url = 'http://localhost/' + path_to_install
            print('Attempting to install software from URL: ' + url)
            page = requests.get(url)
            if page.status_code != 200:
                print('ERROR: %s returned status code = %d'
                        % (url, page.status_code))
                continue
            contents = page.content
            print(contents)

            # TODO: Handle case where the install script returns a form.
            #soup = BeautifulSoup(contents, 'html.parser')
            break  # Only process the first script found

        # Wait for the exploit to trigger by reading from the fifo that the
        # flask server will be writing to.
        checker = ExploitChecker()
        cve_base = os.path.basename(cve_dir)
        exploits_dir = os.path.join(haccs_cmd_dir, 'comfortfuzz/exploits')
        json_out_dir = os.path.join(haccs_cmd_dir, 'comfortfuzz/json_out')
        cmd = ['docker', 'run', '--volume', exploits_dir + ':/exploits',
                '--volume', json_out_dir + ':/json_out', '--rm', '-it',
                'comfortfuzz', './run_exploit', cve_base]
        if not run_cmd(cmd, 'generated exploited', timeout=30):
            # Only print a warning, since the exploit could have perceivably
            # worked and still had returned a non-zero exit code (I would only
            # suppose, since I haven't looked at comfortfuzz).
            print('WARNING: comfortfuzz returned a non-zero exit status, '
                  'as a caution!', file=sys.stderr)

        checker.join(timeout=exploit_timeout)
        found_exploit = checker.result
        if checker.is_alive():
            # Eat the request in case we timed out, so this thread can die!
            print('ERROR: Timed-out in the ExploitChecker! Eating the HTTP '
                  'request...', file=sys.stderr)
            requests.get('http://%s:%s' % (http_server_addr, http_server_port))
            checker.join()
    else:
        print('ERROR: Docker did not initialize!', file=sys.stderr)

    # TODO: Since this is process cleanup, we should put this in a trap.
    # Stop the docker container, and wait for it to die
    image_name = 'aarno-' + cve
    for docker in get_running_dockers(name=image_name):
        stop_docker(docker, image_name)

    return found_exploit
