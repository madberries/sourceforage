#!/usr/bin/env python3
#
# usage: runexploit <path-to-cve-docker>
#
# Convenience script for running the end-to-end piece on an already configured
# docker.

import configparser
import os
import sys
import traceback

from impl.exploit_runner import run_exploit
from impl.utils.file import read_all_lines
from impl.utils.logging import ItemizedLogger, StepFailedException

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print('usage: %s <path-to-cve-docker>' % sys.argv[0], file=sys.stderr)
    else:
        # Perform some basic sanity checks on the CVE directory structure.
        cve_dir = sys.argv[1]
        data_dir = os.path.join(cve_dir, 'data')
        cve_ini_file = os.path.join(cve_dir, '.cve.ini')
        if not os.path.exists(cve_dir):
            print(f"ERROR: CVE directory '{cve_dir}' does not exist",
                  file=sys.stderr)
        elif not os.path.isdir(cve_dir):
            print(f"ERROR: CVE directory '{cve_dir}' is not a directory",
                  file=sys.stderr)
        elif not os.path.isfile(os.path.join(cve_dir, "run.sh")):
            print('ERROR: Unable to locate run.sh script', file=sys.stderr)
        elif not os.path.isfile(cve_ini_file):
            print('ERROR: Unable to locate .cve.ini configuration file',
                  file=sys.stderr)
        elif not os.path.isdir(data_dir):
            print('ERROR: Unable to locate data/ directory', file=sys.stderr)
        else:
            # Everything appears to be normal, but let's see if the PHP
            # application directory is there before we declare success...
            path_to_codebase = None
            for file_or_dir in os.listdir(data_dir):
                full_path = os.path.join(data_dir, file_or_dir)
                if os.path.isdir(full_path):
                    if path_to_codebase is not None:
                        print('ERROR: data/ directory contains more than one '
                              'directory', file=sys.stderr)
                        exit(1)
                    path_to_codebase = full_path
            print(os.path.basename(cve_dir))

            # Read in the CVE ini file.
            config = configparser.ConfigParser()
            config.read(cve_ini_file)
            cve_section = config['cve']

            # Message that is printed upon a successful end-to-end exploit
            success_msg = read_all_lines('success.msg')

            # Extract the configuration variables needed for dockerization.
            cve = cve_section['id']

            log = ItemizedLogger()

            log.new_task(
                f"Running end-to-end exploit on {path_to_codebase}",
                title=cve
            )
            success = True
            try:
                success = run_exploit(cve.lower(), path_to_codebase, log,
                                      pre_configure=False)
                if success:
                    print(success_msg)
                    log.success('Sucessfully triggered exploit')
                else:
                    log.fail('Failed to trigger exploit')
            except StepFailedException:
                # Don't log these since it's obvious from the output that a
                # step failed
                success = False
            except:
                success = False
                log.log_exception(traceback.format_exc())
            finally:
                log.complete_task(success=success)

