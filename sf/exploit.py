import glob
import os
import re
import requests
import subprocess
import sys
import time

from bs4 import BeautifulSoup
from http.server import HTTPServer, BaseHTTPRequestHandler
from requests_html import HTMLSession
from subprocess import PIPE, STDOUT
from threading import Thread
from urllib.parse import urljoin, urlsplit

from .utils.constants import ADMINPASS, DBHOST_REPLACEMENTS, \
                             DBNAME_REPLACEMENTS, DBPASS, DBPASS_REPLACEMENTS, \
                             DBROOT_REPLACEMENTS, DBUSER_REPLACEMENTS, \
                             EXPLOIT_TIMEOUT, HTTP_SERVER_ADDR, \
                             HTTP_SERVER_PORT, POSSIBLE_CONFIG_NAMES, \
                             SF_ROOT_DIR
from .utils.http import get_all_forms, get_form_details, fill_form
from .utils.logging import EXEC_COLOR
from .utils.process import run_cmd, get_running_dockers, stop_docker
from .utils.string import make_replacements, make_title

# TODO: See if we can get rid of this global by somehow accessing the state of
# the handler.
globals()['http_request'] = False
globals()['http_response'] = None


class HTTPHandler(BaseHTTPRequestHandler):

    def do_HEAD(self):
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.end_headers()

    def do_GET(self):
        self.send_response(200)
        self.send_header("Content-type", "text/x-shellscript")
        self.end_headers()
        self.wfile.write(bytes('#!/bin/sh\n\ntouch /tmp/TESTFILE\n\n', 'utf-8'))
        globals()['http_request'] = True

    def log_request(self, code='-', size='-'):
        globals()['http_response'] = code


class ExploitChecker(Thread):

    def __init__(self, log):
        Thread.__init__(self)
        self.log = log
        self.result = False
        self.server = HTTPServer((HTTP_SERVER_ADDR, HTTP_SERVER_PORT),
                                 HTTPHandler)
        self.start()

    def run(self):
        self.log.debug(
            'Started http server on '
            f"{HTTP_SERVER_ADDR}:{HTTP_SERVER_PORT}"
        )
        self.server.handle_request()    # just handle one request

        # Mark the result based on the response from the server.
        if globals()['http_request']:
            if globals()['http_response'] == 200:
                self.result = True
            else:
                self.result = False
        else:
            self.result = False


def run_install_script(install_file, path_to_app, log):
    path_to_install = os.path.relpath(install_file, path_to_app)
    url = 'http://localhost/' + path_to_install
    log.info('Attempting to install software via URL: ' + url)

    session = HTMLSession()
    forms, soup = get_all_forms(url, session, log)
    if len(forms) == 0:
        log.debug('No forms to submit!')
    elif len(forms) > 1:
        log.error('Too many forms!')
    else:
        # Gather and print the form information
        details = get_form_details(forms[0])
        log.debug(f"HTML form details: {details}")

        # Attempting to capture common form input names that one may
        # see on an install page:
        data = {}
        for input_tag in details["inputs"]:
            input_tag_name = input_tag["name"]
            if input_tag_name is None:
                continue
            input_tag_type = input_tag["type"]
            input_tag_val = input_tag["value"]
            to_match = input_tag_name.lower()
            if input_tag_type == "hidden":
                # if it's hidden, use the default value
                data[input_tag_name] = input_tag_val
                log.info(
                    'Applying default value to hidden input, '
                    f"appending {input_tag_name}={input_tag_val}"
                    ' to the request'
                )
            elif input_tag_type == "password":
                # It's probably either the password to the DB, or administrator
                # password to this application, so let's try a heuristic.
                if bool(re.match(r".*admin.*", to_match)):
                    data[input_tag_name] = ADMINPASS
                    log.info(
                        'Matched admin password field, appending '
                        f"{input_tag_name}={ADMINPASS} to the request"
                    )
                else:
                    # I guess it's the DB password??
                    data[input_tag_name] = DBPASS
                    log.info(
                        'Matched DB password field, appending '
                        f"{input_tag_name}={DBPASS} to the request"
                    )
            elif input_tag_type == "radio":
                # Some applications have a radio button group where you
                # can make various selections (i.e. a choice between
                # installing and upgrading).  So let's just match with
                # r".*install.*", and then select the matching one.
                #
                # It's sometimes the case there is another install
                # option that additionally drops database tables, but
                # since we are starting from a fresh database this does
                # not make a difference.
                radio_value = input_tag['value']
                if bool(re.match(r".*install.*", radio_value.lower())):
                    #if radio_value.lower() == 'install':
                    data[input_tag_name] = radio_value
                    log.info(
                        'Selecting "install" radio option, appending '
                        f"{input_tag_name}={radio_value} to the request"
                    )
            elif input_tag_name == "submit":
                data[input_tag_name] = 'submit'
            else:
                # NOTE: We need to match the regex for the DB name last
                #       since it could possibly match either hostname
                #       or username as well.
                if fill_form(
                    data,
                    input_tag_name,
                    to_match,
                    DBHOST_REPLACEMENTS,
                    log,
                    fallback='host'
                ):
                    pass
                elif fill_form(
                    data,
                    input_tag_name,
                    to_match,
                    DBUSER_REPLACEMENTS,
                    log,
                    fallback='user'
                ):
                    pass
                elif fill_form(
                    data,
                    input_tag_name,
                    to_match,
                    DBNAME_REPLACEMENTS,
                    log,
                    fallback='db'
                ):
                    pass
                else:    # Use the default...
                    data[input_tag_name] = input_tag_val

        # Submit the form with a POST request, and check for an OK status code.
        url = urljoin(url, details['action'])
        response = session.post(url, data=data)
        if response.status_code != 200:
            log.warn(
                f'Received non-OK response code ({response.status_code}) '
                'from POST request'
            )
        else:
            soup = BeautifulSoup(response.html.html, "html5lib")
            log.debug(make_title('start of HTTP POST response'))
            log.debug(soup.prettify())
            log.debug(make_title('end of HTTP POST response'))

            # Sometimes there is a continuation link that you have to follow, so
            # let's look for that...
            #
            # TODO: Probably also want to look for another submit button, since
            #       there could very well be another form we have to submit,
            #       but we will burn that bridge when we get there!
            log.debug(f' testing {url} -- {path_to_install}')
            for link in soup.find_all('a', href=True):
                href = link['href']
                href_path = urlsplit(href).path
                # Make sure the href has the correct prefix!
                if href_path == path_to_install:
                    # We found a potential continuation in the install script.
                    log.info(
                        f'Discovered possible continuation (where link={href}). Generating HTTP request...'
                    )
                    page = requests.get(urljoin('http://localhost', href))
                    if page.status_code != 200:
                        log.warn(
                            f'HTTP GET request for continuation page failed!'
                        )
                    else:
                        soup = BeautifulSoup(page.content, "html5lib")
                        log.debug(
                            make_title("result for (cont'd) HTTP GET request")
                        )
                        log.debug(soup.prettify())
                        log.debug(
                            make_title(
                                "end of result for (cont'd) HTTP GET request"
                            )
                        )


def run_exploit0(cve_dir, path_to_app, log, skip_install=False):
    # Step 3) Locate and run the install script (if there is one).
    if not skip_install:
        for possible_script_name in ['install.php', 'installer.php']:
            to_search = path_to_app + '/**/' + possible_script_name
            for install_file in glob.glob(to_search, recursive=True):
                run_install_script(install_file, path_to_app, log)
                break    # Only process the first script found

    # Wait for the exploit to trigger by reading from the fifo that the
    # flask server will be writing to.
    checker = ExploitChecker(log)
    cve_base = os.path.basename(cve_dir)
    volume_dir = os.path.abspath(cve_dir)
    cmd = [
        'docker',
        'run',
        '--volume',
        f"{volume_dir}:/app",
        '--rm',
        '-it',
        'comfortfuzz',
        './run_exploit',
        cve_base
    ]
    if not run_cmd(cmd, 'generated exploited', log, timeout=30):
        # Only print a warning, since the exploit could have perceivably
        # worked and still had returned a non-zero exit code (I would
        # only suppose since I haven't looked at comfortfuzz).
        log.warn(
            'WARNING: comfortfuzz returned a non-zero exit status, as a '
            'caution!'
        )

    checker.join(timeout=EXPLOIT_TIMEOUT)
    found_exploit = checker.result
    if checker.is_alive():
        # Eat the request in case we timed out, so this thread can die!
        log.error('Timed-out in the ExploitChecker! Eating the HTTP request...')
        requests.get('http://%s:%s' % (HTTP_SERVER_ADDR, HTTP_SERVER_PORT))
        checker.join()
    return found_exploit


def run_exploit(cve, path_to_app, log, skip_docker=False, skip_install=False):
    # Extract CVE directory from application path.
    cve_dir = os.path.dirname(os.path.dirname(path_to_app))
    if cve_dir == '':
        log.error(f"Unable to locate CVE directory relative to: {path_to_app}")

    # Step 1) Find a configuration file, and check for hardcoded database
    #         information (i.e. host, user, pass, etc...) replacing the
    #         values needed for our particular setup.
    if skip_docker:
        return run_exploit0(
            cve_dir, path_to_app, log, skip_install=skip_install
        )
    else:
        log.debug(f"Attempting to configure PHP application {path_to_app}...")
        for config_name in POSSIBLE_CONFIG_NAMES:
            to_search = path_to_app + '/**/' + config_name
            for config_file in glob.glob(to_search, recursive=True):
                log.debug(
                    f"Discovered potential configuration file: {config_file}"
                )
                make_replacements(DBHOST_REPLACEMENTS, config_file, log)
                make_replacements(DBNAME_REPLACEMENTS, config_file, log)
                make_replacements(DBUSER_REPLACEMENTS, config_file, log)
                make_replacements(DBPASS_REPLACEMENTS, config_file, log)
                make_replacements(DBROOT_REPLACEMENTS, config_file, log)

    # Step 2) Run the docker container.
    log.info("Starting up docker container...")
    p = subprocess.Popen(['./run.sh'], stdout=PIPE, stderr=STDOUT, cwd=cve_dir)
    found_exploit = False
    try:
        log.log(
            '--------------------------- cmd output ---------------------------',
            text_color=EXEC_COLOR
        )
        initialized = False
        while True:
            output = p.stdout.readline()
            if output == '' and p.poll() is not None:
                break
            if output:
                line = output.strip().decode("utf-8")
                log.log(line, text_color=EXEC_COLOR)
                if line == 'App DB setup complete.':
                    initialized = True
                    break
            else:
                log.warn('Unexpected EOF!')
                break
        log.log(
            '--------------------------- cmd output ---------------------------',
            text_color=EXEC_COLOR
        )

        if initialized:
            # Wait a couple seconds after initialization for good measure!
            time.sleep(2.0)
            found_exploit = run_exploit0(
                cve_dir, path_to_app, log, skip_install=skip_install
            )
        else:
            log.error('Docker did not initialize!')
    finally:
        # TODO: Since this is process cleanup, we should put this in a trap.
        # Stop the docker container, and wait for it to die
        image_name = 'aarno-' + cve
        for docker in get_running_dockers(name=image_name):
            stop_docker(docker, image_name, log)

    return found_exploit
