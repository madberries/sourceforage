import glob
import os
import requests
import subprocess
import sys
import time

from bs4 import BeautifulSoup
from http.server import HTTPServer, BaseHTTPRequestHandler
from subprocess import PIPE, STDOUT

from .exploit_checker import ExploitChecker
from .utils.constants import DBHOST_REPLACEMENTS, DBNAME_REPLACEMENTS, \
                             DBPASS_REPLACEMENTS, DBUSER_REPLACEMENTS, \
                             EXPLOIT_TIMEOUT, HTTP_SERVER_ADDR,        \
                             HTTP_SERVER_PORT, POSSIBLE_CONFIG_NAMES,  \
                             SF_ROOT_DIR
from .utils.process import run_cmd, get_running_dockers, stop_docker
from .utils.string import make_replacements

def run_exploit(cve, path_to_app):
    # Extract CVE directory from application path.
    cve_dir = os.path.dirname(os.path.dirname(path_to_app))
    if cve_dir == '':
        print('ERROR: Unable to locate CVE directory relative to: '
                + path_to_app, file=sys.stderr)

    # Step 1) Find a configuration file, and check for hardcoded database
    #         information (i.e. host, user, pass, etc...) replacing the
    #         values needed for our particular setup.
    for config_name in POSSIBLE_CONFIG_NAMES:
        to_search = path_to_app + '/**/' + config_name
        for config_file in glob.glob(to_search, recursive=True):
            make_replacements(DBHOST_REPLACEMENTS, config_file)
            make_replacements(DBNAME_REPLACEMENTS, config_file)
            make_replacements(DBUSER_REPLACEMENTS, config_file)
            make_replacements(DBPASS_REPLACEMENTS, config_file)

    # Step 2) Run the docker container.
    p = subprocess.Popen([ './run.sh' ], stdout=PIPE, stderr=STDOUT,
                         cwd=cve_dir)
    found_exploit = False
    try:
        initialized = False
        while True:
            output = p.stdout.readline()
            if output == '' and p.poll() is not None:
                break
            if output:
                line = output.strip().decode("utf-8")
                print(line)
                if line == 'App DB setup complete.':
                    initialized = True
                    break
            else:
                print('ERROR: unexpected EOF!', file=sys.stderr)
                break

        if initialized:
            # Wait a couple seconds after initialization for good measure!
            time.sleep(2.0)

            #######################################################################
            # Step 3) Locate and run the install script (if there is one)         #
            #######################################################################
            to_search = path_to_app + '/**/install.php'
            for install_file in glob.glob(to_search, recursive=True):
                path_to_install = os.path.relpath(install_file, path_to_app)
                url = 'http://localhost/' + path_to_install
                print('Attempting to install software from URL: ' + url)
                page = requests.get(url)
                if page.status_code != 200:
                    print('ERROR: %s returned status code = %d'
                            % (url, page.status_code))
                    continue
                contents = page.content
                print(contents)

                # TODO: Handle case where the install script returns a form.
                #soup = BeautifulSoup(contents, 'html.parser')
                break  # Only process the first script found

            # Wait for the exploit to trigger by reading from the fifo that the
            # flask server will be writing to.
            checker = ExploitChecker()
            cve_base = os.path.basename(cve_dir)
            exploits_dir = os.path.join(SF_ROOT_DIR, 'comfortfuzz/exploits')
            json_out_dir = os.path.join(SF_ROOT_DIR, 'comfortfuzz/json_out')
            cmd = ['docker', 'run', '--volume', exploits_dir + ':/exploits',
                    '--volume', json_out_dir + ':/json_out', '--rm', '-it',
                    'comfortfuzz', './run_exploit', cve_base]
            if not run_cmd(cmd, 'generated exploited', timeout=30):
                # Only print a warning, since the exploit could have perceivably
                # worked and still had returned a non-zero exit code (I would only
                # suppose, since I haven't looked at comfortfuzz).
                print('WARNING: comfortfuzz returned a non-zero exit status, '
                      'as a caution!', file=sys.stderr)

            checker.join(timeout=EXPLOIT_TIMEOUT)
            found_exploit = checker.result
            if checker.is_alive():
                # Eat the request in case we timed out, so this thread can die!
                print('ERROR: Timed-out in the ExploitChecker! Eating the HTTP '
                      'request...', file=sys.stderr)
                requests.get('http://%s:%s' % (HTTP_SERVER_ADDR, HTTP_SERVER_PORT))
                checker.join()
        else:
            print('ERROR: Docker did not initialize!', file=sys.stderr)
    finally:
        # TODO: Since this is process cleanup, we should put this in a trap.
        # Stop the docker container, and wait for it to die
        image_name = 'aarno-' + cve
        for docker in get_running_dockers(name=image_name):
            stop_docker(docker, image_name)

    return found_exploit
