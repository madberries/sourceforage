import glob
import os
import requests
import subprocess
import sys
import time

from bs4 import BeautifulSoup
from http.server import HTTPServer, BaseHTTPRequestHandler
from requests_html import HTMLSession
from subprocess import PIPE, STDOUT
from urllib.parse import urljoin

from .exploit_checker import ExploitChecker
from .utils.constants import DBHOST_REPLACEMENTS, DBNAME_REPLACEMENTS, \
                             DBPASS_REPLACEMENTS, DBUSER_REPLACEMENTS, \
                             EXPLOIT_TIMEOUT, HTTP_SERVER_ADDR,        \
                             HTTP_SERVER_PORT, POSSIBLE_CONFIG_NAMES,  \
                             SF_ROOT_DIR
from .utils.http import get_all_forms, get_form_details
from .utils.process import run_cmd, get_running_dockers, stop_docker
from .utils.string import make_replacements


def run_exploit(cve, path_to_app, log, pre_configure=True):
    # Extract CVE directory from application path.
    cve_dir = os.path.dirname(os.path.dirname(path_to_app))
    if cve_dir == '':
        log.error(
            'ERROR: Unable to locate CVE directory relative to: ' + path_to_app
        )

    # Step 1) Find a configuration file, and check for hardcoded database
    #         information (i.e. host, user, pass, etc...) replacing the
    #         values needed for our particular setup.
    if pre_configure:
        log.debug(f"Attempting to configure PHP application {path_to_app}...")
        for config_name in POSSIBLE_CONFIG_NAMES:
            to_search = path_to_app + '/**/' + config_name
            for config_file in glob.glob(to_search, recursive=True):
                log.debug(
                    f"Discovered potential configuration file: {config_file}"
                )
                make_replacements(DBHOST_REPLACEMENTS, config_file, log)
                make_replacements(DBNAME_REPLACEMENTS, config_file, log)
                make_replacements(DBUSER_REPLACEMENTS, config_file, log)
                make_replacements(DBPASS_REPLACEMENTS, config_file, log)

    # Step 2) Run the docker container.
    log.info("Starting up docker container...")
    p = subprocess.Popen(['./run.sh'], stdout=PIPE, stderr=STDOUT, cwd=cve_dir)
    found_exploit = False
    try:
        initialized = False
        while True:
            output = p.stdout.readline()
            if output == '' and p.poll() is not None:
                break
            if output:
                line = output.strip().decode("utf-8")
                print(line)
                if line == 'App DB setup complete.':
                    initialized = True
                    break
            else:
                print('ERROR: unexpected EOF!', file=sys.stderr)
                break

        if initialized:
            # Wait a couple seconds after initialization for good measure!
            time.sleep(2.0)

            # Step 3) Locate and run the install script (if there is one).
            to_search = path_to_app + '/**/install.php'
            for install_file in glob.glob(to_search, recursive=True):
                path_to_install = os.path.relpath(install_file, path_to_app)
                url = 'http://localhost/' + path_to_install
                log.info('Attempting to install software via URL: ' + url)

                session = HTMLSession()
                forms = get_all_forms(url, session, log)
                if len(forms) == 0:
                    log.debug('No forms to submit!')
                elif len(forms) > 1:
                    log.error('Too many forms!')
                else:
                    details = get_form_details(forms[0])
                    url = urljoin(url, details['action'])
                    session.post(url, data={ 'install': 'submit'})

                # TODO: Handle case where the install script returns a form.
                #soup = BeautifulSoup(contents, 'html.parser')
                break    # Only process the first script found

            # Wait for the exploit to trigger by reading from the fifo that the
            # flask server will be writing to.
            checker = ExploitChecker(log)
            cve_base = os.path.basename(cve_dir)
            exploits_dir = os.path.join(SF_ROOT_DIR, 'comfortfuzz/exploits')
            json_out_dir = os.path.join(SF_ROOT_DIR, 'comfortfuzz/json_out')
            cmd = [
                'docker',
                'run',
                '--volume',
                f"{exploits_dir}:/exploits",
                '--volume',
                f"{json_out_dir}:/json_out",
                '--rm',
                '-it',
                'comfortfuzz',
                './run_exploit',
                cve_base
            ]
            if not run_cmd(cmd, 'generated exploited', log, timeout=30):
                # Only print a warning, since the exploit could have perceivably
                # worked and still had returned a non-zero exit code (I would
                # only suppose since I haven't looked at comfortfuzz).
                log.warn(
                    'WARNING: comfortfuzz returned a non-zero exit status,'
                    ' as a caution!'
                )

            checker.join(timeout=EXPLOIT_TIMEOUT)
            found_exploit = checker.result
            if checker.is_alive():
                # Eat the request in case we timed out, so this thread can die!
                log.error(
                    'ERROR: Timed-out in the ExploitChecker! Eating the '
                    'HTTP request...'
                )
                requests.get(
                    'http://%s:%s' % (HTTP_SERVER_ADDR, HTTP_SERVER_PORT)
                )
                checker.join()
        else:
            log.error('ERROR: Docker did not initialize!')
    finally:
        # TODO: Since this is process cleanup, we should put this in a trap.
        # Stop the docker container, and wait for it to die
        image_name = 'aarno-' + cve
        for docker in get_running_dockers(name=image_name):
            stop_docker(docker, image_name, log)

    return found_exploit
