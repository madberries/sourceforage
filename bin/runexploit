#!/usr/bin/env python3
#
# usage: runexploit [-h] ( [-s] | [-d] [-i] cve_dir... )
#
# Discovers and generates PHP exploits automatically (via sourceforge) from NVD
# json data feed
#
# positional arguments:
#   cve_dir           the root directory of the CVE docker
#
# optional arguments:
#   -h, --help        show this help message and exit
#   -s, --success     run all foraged successful exploits
#   -d, --no-docker   do not start a new docker container
#   -i, --no-install  do not run installation steps

import argparse
import configparser
import glob
import os
import sys
import traceback

from sf.exploit_runner import run_exploit
from sf.utils.constants import FORAGED_OUT_DIR
from sf.utils.file import read_all_lines
from sf.utils.logging import ItemizedLogger, StepFailedException

CVE_DIR_ARGNAME = 'cve_dir'
SUCCESS_FLAG = '--success'
NO_DOCKER_FLAG = '--no-docker'
NO_INSTALL_FLAG = '--no-install'


def error_out_and_exit(msg, usage_func=None, exit_code=1):
    if usage_func is not None:
        usage_func()
    print(msg, file=sys.stderr)
    sys.exit(exit_code)


def main_common(cve_dir, skip_docker, skip_install):
    # Perform some basic sanity checks on the CVE directory structure.
    data_dir = os.path.join(cve_dir, 'data')
    cve_ini_file = os.path.join(cve_dir, '.cve.ini')
    if not os.path.exists(cve_dir):
        print(
            f"error: CVE directory '{cve_dir}' does not exist", file=sys.stderr
        )
    elif not os.path.isdir(cve_dir):
        print(
            f"error: CVE directory '{cve_dir}' is not a directory",
            file=sys.stderr
        )
    elif not os.path.isfile(os.path.join(cve_dir, "run.sh")):
        print('error: Unable to locate run.sh script', file=sys.stderr)
    elif not os.path.isfile(cve_ini_file):
        print(
            'error: Unable to locate .cve.ini configuration file',
            file=sys.stderr
        )
    elif not os.path.isdir(data_dir):
        print('error: Unable to locate data/ directory', file=sys.stderr)
    else:
        # Everything appears to be normal, but let's see if the PHP
        # application directory is there before we declare success...
        path_to_codebase = None
        for file_or_dir in os.listdir(data_dir):
            full_path = os.path.join(data_dir, file_or_dir)
            if os.path.isdir(full_path):
                if path_to_codebase is not None:
                    error_out_and_exit(
                        'error: data/ directory contains more than one '
                        'directory',
                        file=sys.stderr
                    )
                path_to_codebase = full_path

        # Read in the CVE ini file.
        config = configparser.ConfigParser()
        config.read(cve_ini_file)
        cve_section = config['cve']

        # Message that is printed upon a successful end-to-end exploit
        success_msg = read_all_lines('success.msg')

        # Extract the configuration variables needed for dockerization.
        cve = cve_section['id']

        log = ItemizedLogger()

        log.new_task(
            f"Running end-to-end exploit on {path_to_codebase}", title=cve
        )
        success = True
        try:
            success = run_exploit(
                cve.lower(),
                path_to_codebase,
                log,
                skip_docker=skip_docker,
                skip_install=skip_install
            )
            if success:
                print(success_msg)
                log.success('Sucessfully triggered exploit')
            else:
                log.fail('Failed to trigger exploit')
        except StepFailedException:
            # Don't log these since it's obvious from the output that a
            # step failed
            success = False
        except:
            success = False
            log.log_exception(traceback.format_exc())
        finally:
            log.complete_task(success=success)
        return success
    return False


def main(cmdline):
    if cmdline.success:
        # Find all exploits under 'foraged/' that we previously marked as a
        # success.
        success_pattern = os.path.join(FORAGED_OUT_DIR, 'cve-*/*/.success')
        success_paths = glob.glob(success_pattern, recursive=False)
        cve_dirs = [os.path.dirname(x) for x in success_paths]
        fmt_msg = 'Running the following (working) exploits in a new container:\n    %s'
    else:
        opts = ''
        if cmdline.no_docker:
            opts += ' ' + NO_DOCKER_FLAG
        if cmdline.no_install:
            opts += ' ' + NO_INSTALL_FLAG
        opts = opts.strip()
        cve_dirs = cmdline.cve_dir
        fmt_msg = 'Running the following exploits [' + opts + ']:\n    %s'

    cves_str = '\n    '.join(cve_dirs)
    print(fmt_msg % cves_str)

    # Run all of the exploits in sequence, marking all of the ones that do
    # not work end-to-end.
    failing_cves = []
    exit_code = 0
    success_str = ''
    for cve_dir in cve_dirs:
        if main_common(cve_dir, cmdline.no_docker, cmdline.no_install):
            success_str += '.'
        else:
            failing_cves.append(cve_dir)
            success_str += 'X'
            exit_code += 1

    # Print out the results and return the number of failing exploits as this
    # process' exit code.
    if len(failing_cves) > 0:
        print(f'{success_str} FAIL!')
        cves_str = '\n    '.join(failing_cves)
        fmt_msg = 'Failing exploits:\n    %s'
        print(fmt_msg % cves_str)
    else:
        print(f'{success_str} SUCCESS!')

    return exit_code


def parse_args():
    """
    parse command line arguments
    """
    parser = argparse.ArgumentParser(
        usage='%(prog)s [-h] ( [-s] | [-d] [-i] cve_dir... )',
        description='Discovers and generates PHP '
        'exploits automatically (via sourceforge) from NVD json data feed'
    )
    parser.add_argument(
        CVE_DIR_ARGNAME, nargs='*', help="the root directory of the CVE docker"
    )
    parser.add_argument(
        '-s',
        SUCCESS_FLAG,
        action='store_true',
        help='run all foraged successful exploits'
    )
    parser.add_argument(
        '-d',
        NO_DOCKER_FLAG,
        action='store_true',
        help='do not start a new docker container'
    )
    parser.add_argument(
        '-i',
        NO_INSTALL_FLAG,
        action='store_true',
        help='do not run installation steps'
    )

    # Parse the CLI arguments.
    args = parser.parse_args()

    # Perform sanity check on the parsed CLI arguments.
    msg = None
    usage_func = lambda: parser.print_usage(file=sys.stderr)
    if not args.success and len(args.cve_dir) == 0:
        error_out_and_exit(
            f'{parser.prog}: error: one or more "{CVE_DIR_ARGNAME}" arguments'
            ' are expected',
            usage_func=usage_func
        )
    if args.success:
        if args.no_install:
            error_out_and_exit(
                f'{parser.prog}: error: {NO_INSTALL_FLAG} can only be use when'
                f' not passing {SUCCESS_FLAG}',
                usage_func=usage_func
            )
        if args.no_docker:
            error_out_and_exit(
                f'{parser.prog}: error: {NO_DOCKER_FLAG} can only be use when'
                f' not passing {SUCCESS_FLAG}',
                usage_func=usage_func
            )
        if len(args.cve_dir) != 0:
            error_out_and_exit(
                f'{parser.prog}: error: no "{CVE_DIR_ARGNAME}" arguments are '
                f'expected when passing the {SUCCESS_FLAG} flag',
                usage_func=usage_func
            )
    else:
        if args.no_install and len(args.cve_dir) > 1:
            error_out_and_exit(
                f'{parser.prog}: error: {NO_INSTALL_FLAG} should only be used '
                'when running a single exploit',
                usage_func=usage_func
            )
        if args.no_docker and len(args.cve_dir) > 1:
            error_out_and_exit(
                f'{parser.prog}: error: {NO_DOCKER_FLAG} should only be used '
                'when running a single exploit',
                usage_func=usage_func
            )

    return args


if __name__ == "__main__":
    args = parse_args()
    # Exit code will be the total number of failing exploits.
    sys.exit(main(args))
